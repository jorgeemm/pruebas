{
  "hash": "a88824fb9e3f91e5592d3b98dbf82080",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Otras cosas\"\n---\n\n\n\n\n\n\n## Crear una secuencia de números: {#secuencia}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsecuencia<-5:15\nsecuencia\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5  6  7  8  9 10 11 12 13 14 15\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(5.5, 10, by = 0.5) #la secuencia irá de 5,5 hasta 10, de 0,5 en 0,5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(5, 10, length.out = 5) #entre el 5 y el 10, sacará una secuencia formada por 5 números\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5.00  6.25  7.50  8.75 10.00\n```\n\n\n:::\n:::\n\n\n\n\nTambién se pueden repetir valores:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvalores <- c(\"yes\", \"no\")\n\nrep(valores, times=3) #Repite la secuencia completa tres veces\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"yes\" \"no\"  \"yes\" \"no\"  \"yes\" \"no\" \n```\n\n\n:::\n\n```{.r .cell-code}\nrep(valores, each=3) #Repite cada uno de los valores del vector 3 veces\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"yes\" \"yes\" \"yes\" \"no\"  \"no\"  \"no\" \n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n## Valores perdidos {#NA}\n\n-   Comprobar si hay valores perdidos: `is.na()` o `anyNA()`. En la consola dirá True o False.\n\n-   Conocer el número de valores perdidos dentro de una variable: `table(datos$var, useNA=\"always\")`.\n\n-   Eliminar todas las observaciones de una base de datos que tengan casos perdidos en alguna de sus variables: `datos <- na.omit(datos)`\n\n<br>\n\n## Crear funciones {#funciones}\n\nPermiten concentrar varios comandos en uno solo.\n\n``` r\nnombre_función <- function (x){\n  argumentos de la función\n}\n```\n\n<br>\n\n### Ejemplos:\n\n-   Función que devuelve el valor de la mitad de un número:\n\n``` r\nfuncionmitad <- function(x){\n  y <- x/2\n  return(y)\n}\n```\n\n-   Función que hace una potencia y añade texto:\n\n``` r\nfuncionpotencia <- function(x,y){\n  potencia <- x^y\n  z <- \"El resultado de la potencia es: \"\n  texto <- paste0(z,potencia)\n  return(texto)\n}\n```\n\n-   Función para crear tablas de frecuencia (como %) automáticas (*función table de stata*):\n\n``` r\ntabla <- function(x,y){\n  tabla_decimal <- table(x,y) %>% prop.table %>% round(4)\n  tabla_porcentaje <- tabla_decimal*100\n  return(tabla_porcentaje)\n}\n```\n\nSi algunas de las funciones creadas se quiere reutilizar habitualmente, existen dos formas fáciles de volver a instalarlas:\n\n1.  Escribiendo estas funciones en un script a parte y usando `source`.\n2.  Crear un paquete propio.\n\n<br>\n\n## Recomendaciones para las variables dicotómicas {#recomendaciones_dicotomicas}\n\nEs recomendable nombrar a la variable como la categoría de referencia. Por ejemplo, en el siguente ejemplo la variable se llama hombre en lugar de sexo porque el 1 se corresponde con los hombres. Es mejor hacerlo de este modo porque facilita la interpretación de los análisis. Por ejemplo, al hacer un summary de la nueva variable, se puede ver fácilmente que el 0.51 indica que la proporción de hombres en la muestra es del 51%.\n\n``` r\ndatos <- datos %>% \n  mutate(hombre=ifelse(SEXO==1, 1, 0))\n```\n\n------------------------------------------------------------------------\n\n## S/O: IRENE\n\n![](images/Imagen%20de%20WhatsApp%202024-12-13%20a%20las%2011.57.28_80b1afe2.jpg){fig-align=\"center\" width=\"50\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}