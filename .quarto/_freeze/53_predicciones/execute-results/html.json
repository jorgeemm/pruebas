{
  "hash": "cee7ed67de42ce8fc7d84da93adc7fe9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Predicciones\"\n---\n\n\n\n\n\n## Validación del modelo de regresión\n\nHay ocasiones en las que queremos determinar la precisión de un modelo a la hora de predecir nuevas observaciones (que no se han utilizado para construir el modelo). En otras palabras, queremos estimar el error de predicción de nuestro modelo. Con **validación cruzada** nos referimos a un conjunto de métodos para medir el rendimiento de un modelo dado en nuevos conjuntos de datos de prueba.\n\nLa idea básica detrás de las técnicas de validación cruzada es la siguiente:\n\n-   Construir el modelo en un conjunto de datos de entrenamiento (*train set*)\n-   Aplicar el modelo en un nuevo conjunto de datos de prueba para hacer predicciones (*test set*)\n-   Calcular los errores de predicción. Si el modelo funciona bien en el conjunto de datos de prueba (*test set*), entonces es bueno.\n\nÉxisten diferentes métricas para cuantificar la calidad general de los modelos de regresión. Hasta ahora nos hemos centrado en el R^2^, pero hay otros como:\n\n-   El **error cuadrático medio** (RMSE), que mide el error predictivo promedio. Es decir, la diferencia promedio entre los valores observados y los valores predichos por el modelo. Cuanto más bajo sea el RMSE, mejor será el modelo.\n-   El **error absoluto medio** (MAE), una alternativa a RMSE que es menos sensible a los valores atípicos. Corresponde a la diferencia promedio, en términos absolutos, entre los resultados observados y predichos. Cuanto más bajo sea el MAE, mejor será el modelo.\n\nExisten diferentes métodos de validación cruzada para evaluar el rendimiento del modelo. A continuación, vamos a ver algunos de los más sencillos y frecuentes.\n\n## El conjunto de validación\n\nÉl método más sencillo consiste en dividir aleatoriamente los datos en dos conjuntos: un conjunto se usa para entrenar el modelo (train set) y el otro para probalo (test set).\n\nVamos a ver un ejemplo. Para ello, abrimos el dataset QoG2017 (*Quality of Government, 2017*) que ya conocemos. Como en ejemplos anteriores, renombramos nuestras 2 variables de interés:\n\n-   ti_cpi (Transparency International Corruption Perception Index) = cpi\n-   mad_gdppc (GDP per capita) = gdp\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqog2017 <- read_dta(\"00_datos/QoG_basic_2017.dta\")\n\ndim(qog2017)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 194 360\n```\n\n\n:::\n\n```{.r .cell-code}\nqog2017 <- qog2017 %>%\n  mutate(cpi = ti_cpi,\n         gdp = mad_gdppc)\n\nsummary(qog2017$cpi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   8.00   28.00   37.00   42.12   54.00   91.00      14 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(qog2017$gdp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    260    3178    7331    9687   13724   30491      84 \n```\n\n\n:::\n:::\n\n\n\nPara que todo funcione bien **es necesario que la base de datos no contenga NAs**. Para ello, procedemos de la siguiente manera:\n\n-   Creamos un nuevo dataset que incluya únicamente las variables que nos interesan\n-   Eliminamos los casos perdidos usando la función `na.omit()` o `na.exclude()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmyvars <- c(\"cpi\", \"gdp\")          # creo un vector con las variables de interés\nqog2017.red<-qog2017[myvars]       # creo un nuevo dataframe con las variables de interés\nqog2017.red<- na.omit(qog2017.red) # elimino los casos perdidos del nuevo dataframe\nsummary(qog2017.red)               # compruebo que el nuevo dataset contiene únicamente las variables de interés\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      cpi             gdp       \n Min.   :16.00   Min.   :  260  \n 1st Qu.:29.00   1st Qu.: 3178  \n Median :40.00   Median : 7331  \n Mean   :45.19   Mean   : 9687  \n 3rd Qu.:58.50   3rd Qu.:13724  \n Max.   :91.00   Max.   :30491  \n```\n\n\n:::\n\n```{.r .cell-code}\ndim(qog2017.red)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110   2\n```\n\n\n:::\n:::\n\n\n\nUna vez tenemos el dataset preparado, pasamos a crear el conjunto de entrenamiento y test. Hay otras muchas maneras de hacerlo y aquí hemos elegido una sencilla, pero hay otras funciones disponibles en el paquete *caret* o *caTools*.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Establecemos la semilla para la reproducibilidad (puede ser cualquier número)\nset.seed(1)\n\n# Creamos un id para las filas\nqog2017.red <- qog2017.red %>%\n  rownames_to_column(var = \"row_id\")\n\n# Dividimos el dataset en 70% para entrenamiento y 30% para prueba\ntrain.data <- qog2017.red %>%\n  sample_frac(0.7) # selecciona aleatoriamente el 70% de las filas del dataset.\n\n# El test set son las filas que no están en el train set\ntest.data <- qog2017.red %>%\n  anti_join(train.data, by = \"row_id\") # se usa para obtener el 30% restante (las filas que no están en el set de entrenamiento), asegurando que no haya filas duplicadas.\n```\n:::\n\n\n\nNota: `set.seet()`establece el número inicial que se usa para generar una secuencia de números aleatorios. De esta manera, nos aseguramos de que obtener el mismo resultado cada vez que se ejecuta el mismo proceso.\n\nA continuación, estimamos el modelo de regresión con los datos de entrenamiento (train.data):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodelo1 <- lm(cpi ~ gdp, data=train.data)\nprint(modelo1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = cpi ~ gdp, data = train.data)\n\nCoefficients:\n(Intercept)          gdp  \n  25.283658     0.002097  \n```\n\n\n:::\n:::\n\n\n\nUna vez hemos estimado el modelo en el conjunto de entrenamiento, pasamos a hacer la predicción. Es decir, usamos los parámetros obtenidos en el modelo1 para estimar yhat (valores predichos) en el conjunto de prueba (test.data):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Usamos el modelo para predecir los valores de CPI en test.data y guardamos el resultado en una nueva columna yhat1\ntest.data <- test.data %>%\n  mutate(yhat1 = predict(modelo1, newdata = test.data))\n\n# Visualizamos los primeros valores de la columna de predicciones\nhead(test.data$yhat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       1        2        3        4        5        6 \n28.63831 43.81926 46.78745 35.61843 27.95946 46.70095 \n```\n\n\n:::\n:::\n\n\n\nComo resultado, el dataset tiene ahora 4 columnas. El id, la variable dependiente (*cpi*), la variable independiente (*gdp*) y el valor predicho (*yhat*). Una vez tenemos estos tres valores, ya podemos calcular la calidad general del modelo de regresión.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(test.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  row_id   cpi    gdp yhat1\n  <chr>  <dbl>  <dbl> <dbl>\n1 3         23  1600.  28.6\n2 4         28  8841.  43.8\n3 5         34 10256.  46.8\n4 8         48  4929.  35.6\n5 9         27  1276.  28.0\n6 10        36 10215.  46.7\n```\n\n\n:::\n:::\n\n\n\nCalculamos el R^2^, el RMSE y el MAE del modelo 1:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(caret)\ndata.frame(R2.m1 = R2(test.data$yhat1, test.data$cpi),\n           RMSE.m1 = RMSE(test.data$yhat1, test.data$cpi),\n           MAE.m1 = MAE(test.data$yhat1, test.data$cpi))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      R2.m1  RMSE.m1   MAE.m1\n1 0.7182977 9.445556 6.936436\n```\n\n\n:::\n:::\n\n\n\nRMSE y el MAE se miden en la misma escala que la variable dependiente. Para tener una medida más fácilmente interpretable, dividimos RMSE por el valor promedio de la variable dependiente. De esta manera obtendremos la *tasa de error de predicción* que varía entre 0 y 1. La predicción será mejor cuanto menor sea su valor:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRMSE(test.data$yhat1, test.data$cpi)/mean(test.data$cpi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2359602\n```\n\n\n:::\n:::\n\n\n\nEste método de validación cruzada es útil cuando tenemos una muestra suficientemente grande para particionar. Una desventaja es que construimos el modelo a partir de fracción del conjunto de datos, posiblemente omitiendo alguna información interesante sobre los datos, lo que nos puede conducir a un mayor sesgo. Por lo tanto, la tasa de error de la prueba puede ser muy variable, dependiendo de qué observaciones se incluyen en el conjunto de entrenamiento y qué observaciones se incluyen en el conjunto de validación.\n\n## Método *Leave-one-out* (LOOCV)\n\nLa validación cruzada dejando uno fuera (método *leave-one-out)* funciona de la siguiente manera:\n\n-   Dejar un único caso fuera y construye el modelo con el resto del dataset (n-1)\n-   Valida el modelo con dicho dato, y guarda el error de predicción asociado\n-   Repite el proceso tantas veces como casos (n) tenemos\n-   Computa el error de predicción total, que es el promedio de todos los errores estimados en cada paso\n\nPara cada uno de los casos de la muestra, hace una regresión con el resto del dataset, y testea esta regresión con el que se ha quedado apartado. Este proceso se repite con todos los casos, calculando el error de todas estas regresiones y la media de ellos. Con esta forma de realizar predicciones, todos los casos son usados tanto en la muestra de entrenamiento como en la de testeo. (*No tiene por qué ser necesariamente un mejor modelo que el anterior*)\n\nVamos a ver un **ejemplo** con nuestros datos:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntrain.control <- trainControl(method=\"LOOCV\") # Con la función trainControl definimos el tipo de método (loocv en este caso)\n# Entrenamos el modelo\nmodelo2 <- train(cpi ~., data=qog2017.red, method=\"lm\", trControl=train.control) # ~. significa que utilice todas las varaibles del dataset, en lugar de tener que escribirlas todas una por una.\nprint(modelo2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression \n\n110 samples\n  2 predictor\n\nNo pre-processing\nResampling: Leave-One-Out Cross-Validation \nSummary of sample sizes: 109, 109, 109, 109, 109, 109, ... \nResampling results:\n\n  RMSE      Rsquared     MAE     \n  24.71235  0.004517315  18.08182\n\nTuning parameter 'intercept' was held constant at a value of TRUE\n```\n\n\n:::\n:::\n\n\n\nLa función `print()` nos devuelve el resultado del modelo calculado con el método LOOCV. Como veis, nos devuelve el valor del RMSE, R^2^y MAE. Para facilitar la interpretación, volvemos a calcular la *tasa de error de predicción*. En primer lugar, tenemos que extraer el valor de RMSE de la lista de resultados del modelo (lo podéis consultar haciendo click sobre el modelo2):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqog2017.red$RMSE.m2<-modelo2$results$RMSE\nhead(qog2017.red)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  row_id   cpi    gdp RMSE.m2\n  <chr>  <dbl>  <dbl>   <dbl>\n1 1         31  5375.    24.7\n2 2         36  3513.    24.7\n3 3         23  1600.    24.7\n4 4         28  8841.    24.7\n5 5         34 10256.    24.7\n6 6         81 25584.    24.7\n```\n\n\n:::\n:::\n\n\n\nComos veis, el dataframe contiene ahora nueva columna RMSE.m2. Ya podemos dividir el RMSE por la media de la variable dependiente (cpi)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(qog2017.red$RMSE.m2/mean(qog2017.red$cpi))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5468433\n```\n\n\n:::\n:::\n\n\n\nLa ventaja del método LOOCV es que usamos todos los puntos de datos para reducir el sesgo potencial. La desventaja es que el proceso se repite tantas veces como casos hay, lo que tiene un coste computacional importante si la muestra es muy grande.\n\n## K-fold *cross validation*\n\nEl método de validación cruzada de *k-fold* evalúa el rendimiento del modelo en diferentes subconjuntos de los datos de entrenamiento y luego calcula la tasa de error predictivo promedio. El proceso es el siguiente:\n\n-   Dividir al azar el conjunto de datos en k-subconjuntos (k-folds)\n-   Reservar un subconjunto y entrenar el modelo en todos los demás subconjuntos\n-   Probar el modelo en el subconjunto reservado y registrar el error de predicción\n-   Repetir este proceso hasta que cada uno de los k subconjuntos haya servido como conjunto de prueba.\n-   Calcular el promedio de los errores registrados. Esto se llama el *error de validación* cruzada que sirve como la métrica de rendimiento para el modelo.\n\nLa ventaja más obvia de este método, en comparación con LOOCV, es computacional. Una ventaja menos obvia, pero potencialmente más importante, es que a menudo proporciona estimaciones más precisas de la tasa de error de prueba que LOOCV (James et al., 2014).\n\nPregunta clave: ¿cómo elegir el valor correcto de k? No es difícil ver que un valor pequeño de k (p.ej., k=2) nos lleva a un enfoque parecido al del conjunto de validación que vimos en primer lugar. Por el contrario, valores altos de k (p.ej., k=m) nos lleva al enfoque de LOOCV. En general, usaremos valores intermedios (5, 10, incluso 20)\n\nVamos a hacer un ejemplo con k=10\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Definimos el training control para 10 folders\nset.seed(123) \ntrain.control <- trainControl(method=\"cv\", number=10)  # en este caso, usamos el método \"cv\"\n# Entrenamos el modelo\nmodelo3 <- train(cpi ~., data=qog2017.red, method=\"lm\", trControl=train.control)\nprint(modelo3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression \n\n110 samples\n  3 predictor\n\nNo pre-processing\nResampling: Cross-Validated (10 fold) \nSummary of sample sizes: 99, 98, 98, 100, 98, 101, ... \nResampling results:\n\n  RMSE      Rsquared  MAE     \n  24.82126  NaN       18.30197\n\nTuning parameter 'intercept' was held constant at a value of TRUE\n```\n\n\n:::\n:::\n\n\n\nComo en el ejemplo anterior, el modelo calculado a través de “cv” nos devuelve el RMSE, R^2^ y MAE. Al igual que hicimos arriba, extraemos el RMSE para calcular la tasa de error de predicción de la siguiente manera:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqog2017.red$RMSE.m3<-modelo3$results$RMSE         # extraemos RMSE del modelo3\nhead(qog2017.red)                                 # comprobamos que se ha añadido al data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  row_id   cpi    gdp RMSE.m2 RMSE.m3\n  <chr>  <dbl>  <dbl>   <dbl>   <dbl>\n1 1         31  5375.    24.7    24.8\n2 2         36  3513.    24.7    24.8\n3 3         23  1600.    24.7    24.8\n4 4         28  8841.    24.7    24.8\n5 5         34 10256.    24.7    24.8\n6 6         81 25584.    24.7    24.8\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean(qog2017.red$RMSE.m3/mean(qog2017.red$cpi))   # calculamos la tasa del error de predicción\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5492534\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}