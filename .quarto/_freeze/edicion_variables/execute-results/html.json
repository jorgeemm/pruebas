{
  "hash": "21c3bd4b80766720517ac0ba32360db9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Edición de variables\"\n---\n\n```{=html}\n<style>\nbody {\ntext-align: justify}\n</style>\n```\n\n\n\n\n\n\n\n\n## Edición de variables {.tabset .tabset-fade .tabset-pills}\n\n### 1. Renombrar una variable\n\n**Opción 1**:\n\n``` r\nDatos <- rename(Datos, nombre_nuevo = nombre_viejo)\n```\n\n**Opción 2**:\n\n``` r\ndatos <- datos %>% rename(nombre_nuevo = nombre_viejo)\n```\n\nSe puede cambiar el nombre de varias variables a la vez:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncolnames(Datos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pclass\"   \"survived\" \"name\"     \"sex\"      \"age\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nDatos<-Datos %>% rename(\n  clase=pclass,\n  nombre=name,\n  sexo=sex,\n  edad=age)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncolnames(Datos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"clase\"    \"survived\" \"nombre\"   \"sexo\"     \"edad\"    \n```\n\n\n:::\n:::\n\n\n\n\n**Opción 3**:\n\nSe pueden renombrar las variables directamente al abrir la base de datos gracias al pipe:\n\n``` r\ndatos <- read_xlsx(\"dirección_datos-xlsx\") %>% \n  rename(nombre_nuevo = nombre_viejo,\n         nombre_nuevo = nombre_viejo,\n         ...)\n```\n\n------------------------------------------------------------------------\n\n### 2. Recodificar una variable (o crear una nueva)\n\nPara poder recodificar y crear varaibles se usa el comando `mutate` (*de dplyr*). Este es de gran utilidad si se usa junto a comandos que permiten añadir condiciones lógicas como `ifelse` o `case_when`.\n\n<br>\n\n**Pasos previos antes de recodificar una variable**\n\nAntes de recodificar una variable es necesario conocer cómo es la variable original. Para ello:\n\n1.  Se mira de qué tipo es la varible (numérica -numeric/dbl- o factor) gracias al comando `class`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(Datos$edad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n2.  Tambien conviene realizar una tabla para conocer el contenido de la variable, así como su distribución:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(Datos$clase, useNA=\"ifany\") #La opción useNA=\"ifany\" es opcional, y se añade para que en la tabla se muestren también los valores perdidos.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  1   2   3 \n322 273 702 \n```\n\n\n:::\n:::\n\n\n\n\n<br>\n\n**Crear una nueva variable a partir de operaciones sobre otras existentes**\n\n-   Ej1.: calcular la edad de los encuestados a partir del año de nacimiento\n\n``` r\ndatos <- datos %>% \n  mutate(edad = año_actual - año_nacimiento)\n```\n\n-   Ej2.: crear una varieble para el porcentaje de voto de un partido a partir de los votos totales:\n\n``` r\ndatos <- datos %>% \n  mutate(votosFO_porcentaje = votos_FO/votostotales*100)\n```\n\n<br>\n\n**Recodificar con el comando case_when**\n\n``` r\nDatos <- Datos %>%\n  mutate(edad = case_when(\n    edad == 29 ~ 30, # reemplaza 29 por 30\n    edad == 2 ~ 3, # reemplaza 2 por 3\n    TRUE ~ edad)) # Mantiene iguales los valores que no cambian.\n```\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDatos <- Datos %>%\n  mutate(clase_rec = case_when(\n    clase %in% c(2, 3) ~ 0, # Si 'clase' es 2 o 3, asigna \"0\"\n    TRUE ~ clase)) \n\ntable(Datos$clase_rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0   1 \n975 322 \n```\n\n\n:::\n:::\n\n\n\n\nLa opción TRUE en este comando significa \"todos los demás valores\". Si no se añadiera, todos los valores que no coinciden con las condiciones se enviarían a perdidos (NA).\n\n<br>\n\n**Recodificar con el comando ifelse**\n\nEl comando ifelse es una secuancia lógica con tres elementos. Un primer número, que es la categoría que se quiere transformar, un segundo número, que es en el que se transforma, y una tercera condición para el resto de valores. Esta puede ser otro número, NA o otra secuencia de ifelse.\n\n``` r\nDatos <- Datos %>%\n  mutate(edad = ifelse(edad == 29, 30, ifelse(edad == 2, 3, edad)))\n\nDatos <- Datos %>%\n  mutate(clase_rec2 = ifelse(clase == 1, 1,\n                             ifelse(clase %in% c(2, 3), 0, NA)))\n```\n\n<br>\n\nLas **variables categóricas** se recodifidan del siguente modo:\n\n1.  Transformándolas en una variable numérica:\n\n``` r\n#Por separado:\nDatos <- Datos %>% \n  mutate(sexo = as.numeric(sexo)) %>% \n  mutate(sexo = case_when(\n    sexo == 1 ~ 0,\n    sexo == 2 ~ 1,\n    TRUE ~ sexo\n  ))\n  \n#A la vez:\nDatos <- Datos %>% \n  mutate(as.numeric(sexo) = case_when(\n    sexo == 1 ~ 0,\n    sexo == 2 ~ 1,\n    TRUE ~ sexo\n  ))\n```\n\n*Es la opcion más útil si se quiere modificar una variable con muchas categorías*\n\n2.  Escribiendo las etiquetas entre \"\":\n\n``` r\nDatos <- Datos %>%\n  mutate(sexo = case_when(\n    sexo == \"female\" ~ \"mujer\",  \n    sexo == \"male\" ~ \"hombre\",   \n    TRUE ~ sexo                  \n  ))\n```\n\n*Esta opción es la más cómoda si la variable tiene pocas categorías.*\n\n3.  Especificando los niveles que se quieren modificar:\n\n``` r\ndatos <- datos %>%\n  mutate(estudios_universitarios = case_when(\n    estudios %in% levels(estudios)[1:5] ~ 0,  # Agrupar niveles 1 a 5 en 0\n    estudios %in% levels(estudios)[6] ~ 1,    # Agrupar nivel 6 en 1 \n    TRUE ~ NA_real_                           \n  ))\n```\n\n*Esta opción es util si se quiere convertir en dicotómica una variable categórica con muchas categorías, aunque la primera opción es igual de buena en estos casos*\n\n<br>\n\nOtros **ejemplos** de recodificar variables:\n\n-   Se pueden utilizar símbolos lógicos como el \\>,\\<,\\|,& etc a la hora de recodificar variables\n\n``` r\ndatos<-datos %>%\n  mutate(municipio_cat=ifelse(población>=20000,\"Ciudad\",\"Pueblo\") %>% \n           as.factor())\n```\n\n-   También se pueden realizar operaciones entre variables al mismo tiempo que se recodifican. Ej.: calcular el apoyo en cada municipio a los partidos principales:\n\n``` r\nelec23 <- elec23 %>% \n  mutate(apoyo = case_when(\n    CA==\"Galicia\" ~ PP+BNG+PSOE+SUMAR+VOX,\n    CA==\"Cataluña\" ~ PP+PSOE+SUMAR+VOX+JxCAT+ERC,\n    CA==\"País Vasco\" ~ PP+PSOE+SUMAR+VOX+PNV+BILDU,\n    T ~ PP+PSOE+SUMAR+VOX),\n  apoyo=apoyo/Votantes*100)\n```\n\n<br>\n\n#### Otras opciones de mutate\n\n1.  `mutate_if`. Se hacen cambios en múltiples variables que cumplan con una característica especificada. Es especialmente útil para transformar variables de un tipo a otro. Por ejemplo:\n\n    -   Convertir todas las variables de tipo factor a carácter: `mutate_if(is.factor, as.character)`\n    -   Estandardizar (=0, sd=1) todas las variables numéricas del dataset: `mutate_if(is.numeric, scale)`\n    -   Cuando se estandariza, el valor 0 de una observación implica que esta se corresponde a la media, y el 1 que esa observación está un punto por encima de la desviación típica.\n\n2.  `mutate_at`. Cambia diferentes varaibles especificadas en un vector específico.\n\n    -   Estandarizar una variable: `mutate_at (c(\"n\", \"edad\"), scale)`\n    -   Convertir una escala en logarítmica: `mutate_at (c(“pib\", “poblacion\"), log)`\n\n3.  `mutate_all`. Permite hacer cambios en todas las variables de un dataframe. Ej.: `mutate_all(as.character)`\n\n4.  `across`. Permite hacer cambios a varias variables a la vez dentro de la función básica de mutate. Ejs.:\n\n    -   `mutate(across(c(n, edad), round))`\n    -   `mutate(across(where(is.numeric), round))`\n    -   `mutate(across(starts_with(“nombr\"), tolower))`\n\n------------------------------------------------------------------------\n\n### 3. Añadir etiquetas a la variable\n\nVer las etiquetas de una variable: `attr(datos$var, \"labels\")`:\n\n**Para cambiar las etiquetas se usa el comando factor** *(de dyplr)*\n\n``` r\ndatos <- datos %>% \n  mutate(variable = factor(variable, \n                    levels = c(1,2,3),\n                    labels = c(\"Etiqueta1\",\"Etiqueta2\",\"Eriqueta3\")))\n```\n\n-   `levels` = c(1,2,3) indica el conjunto de números correspondientes con los valores de cada categoría de la variable.\n-   `labels` =c(\"Etiqueta1\"...) indica las etiquetas correspondientes con cada valor especificado anteriormente. Por ejemplo, en este caso a la categoría de la variable que se identifica con un 1 se le asignaría la etiqueta \"Etiqueta1\".\n-   Ej. de cómo añadir etiquetas:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntable(datos$mujer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    0     1 \n15023 14178 \n```\n\n\n:::\n\n```{.r .cell-code}\ndatos <- datos %>%\n  mutate(mujer = factor(mujer, levels = c(0, 1), labels = c(\"Hombre\",\"Mujer\"))) \n\ntable(datos$mujer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nHombre  Mujer \n 15023  14178 \n```\n\n\n:::\n:::\n\n\n\n\nSi se quiere etiquetar algún carácter de una variable numérica sin transformarla en factor, se puede usar el siguiente comando:\n\n``` r\nlibrary(labelled)\nval_labels(datos$variable) <- c(Etiqueta1 = 0, Etiqueta2 = 1)\n```\n\nEste comando también es útil en el caso de escalas: por ejemplo, en la escala de ideología del 1 al 10 para poner que el 1 es extrema izquierda y el 10 extrema derecha, pero dejarlo como numérico y sin necesidad de etiquetar todas las categorías.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(datos$ideol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nval_labels(datos$ideol) <- c(Extrema_izq = 1, Extrema_dcha = 10)\n\nclass(datos$ideol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nval_labels(datos$ideol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Extrema_izq Extrema_dcha \n           1           10 \n```\n\n\n:::\n:::\n\n\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}